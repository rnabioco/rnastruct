---
title: "generate_reactivities"
author: "Kent Riemondy RBI"
date: "1/9/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(cache = TRUE)
```

```{r libs}
source("../../R/constants.R")
library(doParallel)
```

```{r load_dat}
files <- dir(file.path(data_dir, "mismatches"),
             pattern = "bedgraph.gz",
             recursive = TRUE,
             full.names = TRUE)

a <- read_bedgraph(files[8])
b <- read_bedgraph(files[16])

bed_intersect_allrows <- function(bed_a, bed_b){
    
    bed_intersect(bed_a, bed_b, suffix = c("", ".ut")) -> intersecting
    bed_intersect(bed_a, bed_b, invert = T)  -> non_intersecting
    filter(intersecting, .overlap != 0) -> overlapping
    
    filter(intersecting, .overlap == 0) %>% 
      select(chrom:value) %>% 
      anti_join(overlapping, by = c("chrom", "start", "end")) %>% 
      unique() -> adjacent
    
    bind_rows(overlapping, non_intersecting) %>% 
      bind_rows(adjacent) -> all_dat
    all_dat
}
```

```{r eval = F}
dat <- bed_intersect_allrows(a, b) %>% 
  mutate(
    value.ut = ifelse(is.na(value.ut),
                  0,
                  value.ut),
    pDMS = value - value.ut) %>% 
  select(-.overlap)

# drop sites with > 5% mutation rate in untreated samples
dat <- filter(dat, 
              value.ut < 0.05)

# drop sites with pDMS == 0 for now (revisit)
dat <- filter(dat,
              pDMS != 0)

dat_bg <- dat %>% 
  select(chrom:end, pDMS)

kentr::write_gztsv(dat_bg, "dms_ratio.bedgraph", col_names = FALSE)
```


```{r parse_fileids}
mdata <- data_frame(fpath = files,
                    fid = basename(files)) %>% 
  separate(., fid, c("id", "s", "strand", "type"), 
           sep = "_", remove = F) %>% 
  select(-s) %>% 
  mutate(treatment = ifelse(str_detect(id, "DMS"),
                            "DMS",
                            "Untreated"),
         genotype = str_split(id, "-", simplify = T) %>% .[, 2],
         strand = ifelse(strand == "pos",  #first strand library
                         "+",
                         "-"),
         type = str_replace(type, ".bedgraph.gz", ""))

matched_mdata <- mdata %>% 
  filter(!str_detect(type, "depth")) %>% 
  select(fpath, genotype, type, strand, treatment) %>% 
  spread(treatment, fpath) 

matched_mdata_depth <- mdata %>% 
  filter(str_detect(type, "depth")) %>% 
  select(fpath, genotype, type, strand, treatment) %>% 
  spread(treatment, fpath) 

matched_mdata <- left_join(matched_mdata,
                           matched_mdata_depth,
                           by = c("genotype", "strand"), 
                           suffix = c("", "_depth"))
                           
# make list of each DMS versus untreated file path
file_list <- map2(matched_mdata$DMS, 
     matched_mdata$Untreated, ~list(.x, .y))
```

```{r plot_nuc_freq}
fasta <- "~/Projects/shared_dbases/genomes/GRCh38.primary_assembly.genome.fa"

#' Split interval into single nucleotide intervals. 
#' @params df trbl_interval 
#' @return trbl_interval
split_to_nt <- function(df){

  multint_ivl <- df %>% 
    filter(end - start > 1)
  
  if (nrow(multint_ivl) == 0){
    return(df)
  }
  
  total_nts <- mutate(multint_ivl, 
                      ivl_length = end - start) %>% 
    pull(ivl_length) %>% 
    sum(.)
  
  res <- multint_ivl %>% 
    rowwise() %>% 
    mutate(.start = list(seq(start, end, by = 1))) %>%
    ungroup() %>% 
    unnest() %>% 
    mutate(.end = .start + 1) %>% 
    filter(.start != end) %>% 
    mutate(start = .start,
           end = .end) %>% 
    select(-.start, -.end)
  
  if(nrow(res) != total_nts){
      stop(paste("error in expanding single nucleotide ivls",
                  "expected", total_nts, "rows"), 
           call. = F)
  }
  
  join_cols <- colnames(df)
  single_nt_ivls <- df %>% 
    anti_join(multint_ivl, by = join_cols)
  
  res <- bind_rows(res, single_nt_ivls)
  
  res <- bed_sort(res)
  return(res)
}

#' Calculate number of nucleotides observed at each single nucleotide
#' 
nuc_frequencies <- function(df, min_dms_ratio = 0.01, bed_strand = "+"){
  
  filter_df <- df %>% 
    filter(value > min_dms_ratio)
  
  split_df <- split_to_nt(filter_df)
  
  ut_seqs <- mutate(split_df,
           strand = bed_strand) %>% 
    get_sequences(fasta)
  
  if(any(nchar(ut_seqs$seq) > 1)){
    stop(paste("multiple nucleotides found at row",
         which(nchar(ut_seqs$seq) > 1)[1]))
  }
  
  return(count(ut_seqs, seq))
}

#' filter x bedgraph for a minimum depth in y bed
#' @param x bedgraph tibble
#' @param y bedgraph tibble
#' @param min_depth minimum depth for x ivls
#' @param depth_col column name in y that contains depth measurements
filter_depth <- function(x, y, min_depth = 10, depth_col = "value"){
  x$.id <- seq_len(nrow(x))
  res <- bed_intersect(x, y, suffix = c("", ".y")) %>% 
    filter(.overlap > 0)
  res <- filter(res, 
                value.y > min_depth)
  good_ivls <- unique(res$.id)
  res <- filter(x, .id %in% good_ivls)
  res <- select(res, -.id)
  res
}

```

```{r}
plot_mismatch_prop <- function(df, 
                               step_size = 0.5,
                               strand = "+",
                               return_plot = FALSE, 
                               plot_title = ""){
  dms_ratios <- seq(0, 1, step_size)
  
  res <- map(dms_ratios, 
             ~nuc_frequencies(df, .x, bed_strand = strand))
  
  names(res) <- dms_ratios
  res <- bind_rows(res, .id = "dms_ratio")
  
  #compute proportions
  res <- res %>% 
    group_by(dms_ratio) %>% 
    mutate(total_count = sum(n),
           prop = n / total_count)
  
  totals <- res %>% 
    select(dms_ratio, total_count) %>% 
    mutate(total_count = formatC(total_count, big.mark = ",")) %>% 
    unique()
  
  p <- ggplot(res, aes(dms_ratio, prop)) +
    geom_line(aes(colour = seq, group = seq)) +
    ylim(0, 1) + 
    labs(x = "Mismatch frequency\ncutoff per base",
         y = "Proportion",
         title = plot_title) +
    scale_color_viridis(discrete = T) +
    geom_text(data = totals, aes(x = dms_ratio, 
                                 y = 0.9, 
                                 label = total_count),
              angle = 90) 
 
  if(return_plot) {
    return(p)}
  else {
    print(p)
  }
}

```

## DMS-treated nucleotide distribution

```{r dms, fig.height = 12, fig.width = 20}
matched_mdata <- matched_mdata %>% arrange(desc(type))

registerDoParallel(cores = 3)
res_dms <- foreach(i = iter(matched_mdata, 
                        by = "row"), 
               .export = c("plot_mismatch_prop",
                           "read_bedgraph",
                           "filter_depth")) %dopar% {
  x <- filter_depth(read_bedgraph(i$DMS),
               read_bedgraph(i$DMS_depth),
               min_depth = 2)
                 
  plot_mismatch_prop(x,
                     strand = i$strand,
                     step_size = 0.2, 
                     plot_title = str_c(i$type, "", i$genotype, " ", i$strand),
                     return_plot = TRUE)
}

plt <- plot_grid(plotlist = res_dms, 
          ncol = 6)
plt
save_plot("dms_treated_nucleotide_profiles.pdf", 
          plt, base_height = 12, base_width = 20)
```


## Untreated nucleotide distribution

```{r untreated, fig.height = 12, fig.width = 20}
registerDoParallel(cores = 3)
res_untreated <- foreach(i = iter(matched_mdata, 
                        by = "row"), 
               .export = c("plot_mismatch_prop",
                           "read_bedgraph",
                           "filter_depth")) %dopar% {
  x <- filter_depth(read_bedgraph(i$Untreated),
               read_bedgraph(i$Untreated_depth),
               min_depth = 2)
                 
  plot_mismatch_prop(x,
                     strand = i$strand,
                     step_size = 0.2, 
                     plot_title = str_c(i$type, "", i$genotype, " ", i$strand),
                     return_plot = TRUE)
}

plt <- plot_grid(plotlist = res_untreated, ncol = 6)

plt
save_plot("untreated_nucleotide_profiles.pdf", 
          plt, base_height = 12, base_width = 20)
```

## Coverage
  Try to figure out the number of genes found in each experiment that have a single position with at least 100 nucleotides of coverage. 
  
```{r coverage}
dfs <- map(unique(matched_mdata$DMS_depth), 
           ~read_bedgraph(.x))

dfs <- map(dfs,
           ~filter(.x, value > 100))

dfs <- map2(dfs, matched_mdata$strand[1:6], 
            ~mutate(.x, strand = .y))

dfs <- map2(dfs, rep(seq(1:3), each = 2),
            ~mutate(.x, expt = .y))

m_dfs <- map(dfs, 
             ~bed_merge(.x, 
                        coverage = max(value),
                        strand = unique(strand),
                        expt = unique(expt)))

merged_expts <- bind_rows(m_dfs)
```

### exonic or intronic regions found
```{r find_dense_regions}
genes <- read_bed12(file.path(db_dir, "annotations", "GRCh38_genes.bed.gz"))
genes <- bed12_to_exons(genes) %>% group_by(strand)

geneic_regions <- merged_expts %>% 
  group_by(strand) %>% 
  bed_intersect(genes, suffix = c("", ".y")) %>% 
  select(chrom:coverage, name.y) %>% 
  group_by(chrom, start, end, strand, expt, coverage) %>% 
  summarize(genes = values_unique(name.y)) %>% 
  ungroup()

geneic_regions %>% 
     group_by(genes) %>% 
  summarize(n_expts = length(unique(expt))) %>% 
  count(n_expts)

introns <- genes %>% 
    group_by(name) %>% 
    arrange(start, .by_group = T) %>% 
    mutate(.start = end, 
           .end = lead(start),
          start = .start, 
          end = .end) %>% 
     dplyr::select(-.start, -.end) %>% 
     dplyr::filter(!is.na(start),
           !is.na(end),
           start < end) %>% 
  bed_sort() %>% 
  group_by(strand)

intronic_regions <- merged_expts %>% 
  group_by(strand) %>% 
  bed_intersect(introns, suffix = c("", ".y")) %>% 
  select(chrom:coverage, name.y) %>% 
  group_by(chrom, start, end, strand, expt, coverage) %>% 
  summarize(genes = values_unique(name.y)) %>% 
  ungroup()

intronic_regions %>% 
  group_by(genes) %>% 
  summarize(n_expts = length(unique(expt))) %>% 
  count(n_expts)
```

### alternative approach

Find windows with at least 80% of the nucleotides with > 100 coverage

```{r window_approach}

map(dfs, 
    function(x){
      dplyr::filter(x, value > 100) %>% 
        bed_merge(max_dist = 5, prop_greater_than_100 = sum(value > 100) / (max(end) - min(start))) %>%
        dplyr::filter(prop_greater_than_100 > .8) %>% 
        bed_sort()
})
```

### annotate good coverage regions

```{r pull_annotattions}

gtf <- import("~/Projects/shared_dbases/annotation/gencode.v26.basic.annotation.gtf")
gtf <- as.data.frame(gtf)
tx2gene <- dplyr::filter(gtf, type == "transcript") %>% 
  dplyr::select(transcript_id , gene_name) %>% 
  unique()
  
geneic_regions <- geneic_regions %>% 
  left_join(tx2gene, by = c("genes" = "transcript_id")) %>% 
  unique()
```


```{bash}
java \
  -cp ~/Downloads/VARNAv3-93.jar fr.orsay.lri.varna.applications.VARNAcmd \
  -sequenceDBN CGCGUUUUCGCG \
  -structureDBN "((((....))))" \
  -colorMap "1;1;1;1;1;0.1;2;3.5;3;6;7" \
  -zoom 1.2 -o "out.png"

```